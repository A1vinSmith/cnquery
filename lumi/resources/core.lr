mondoo {
  version() string
  build() string
  resources() []string
}

parse {
  // builtin functions:
  // date(value, format) time
}

time {
  now() time
  second() time
  minute() time
  hour() time
  day() time
}

parse.ini {
  init(path string, delimiter string)
  delimiter() string
  file() file
  content(file) string
  sections(content, delimiter) map[string]map[string]string
  params(sections) map[string]string
}

parse.json {
  init(path string)
  file() file
  content(file) string
  params(content) dict
}

platform {
  name string
  title string
  family []string
  release string
  arch string
  kind string
  // TODO: rename to runtime
  execenv string
}

command {
  init(command string)
  command string
  stdout() string
  stderr() string
  exitcode() int
}

pam.conf {
  init(path string)
  files() []file
  content(files) string
  services(files) map[string][]string
}

powershell {
  init(script string)
  script string
  stdout() string
  stderr() string
  exitcode() int
}

file {
  init(path string)
  path string
  basename(path) string
  dirname(path) string
  content(path, exists) string
  exists() bool
  permissions() file.permissions
  size() int
  user() user
  group() group
}

file.permissions {
  mode int
  user_readable bool
  user_writeable bool
  user_executable bool
  group_readable bool
  group_writeable bool
  group_executable bool
  other_readable bool
  other_writeable bool
  other_executable bool
  suid bool
  sgid bool
  sticky bool
}

files.find {
  []file
  from string
  xdev() bool
  type() string
  regex() string
  permissions() int
  name() string
}

sshd.config {
  init(path string)
  file() file
  content(file) string
  params(content) map[string]string
  ciphers(params) []string
  macs(params) []string
  kexs(params) []string
}

package {
  init(name string)

  name string
  version string
  arch string
  epoch string

  format string
  status() string
  description string

  available string
  installed bool
  outdated() bool
}

packages {
  []package
}

kernel {
  parameters() map[string]string
  modules() []kernel.module
}

kernel.module {
  init(name string)

  name string
  size string
  loaded bool
}

ntp.conf {
  init(path string)
  file() file
  content(file) string
  settings(content) []string
  servers(settings) []string
  restrict(settings) []string
  fudge(settings) []string
}

rsyslog.conf {
  init(path string)
  files() []file
  content(files) string
  settings(content) []string
}

osupdate {
  name string
  category string
  severity string
  restart bool
  format string
}

os {
  env() map[string]string
  path() []string
  uptime() string
  updates() []osupdate
  rebootpending() bool
  hostname() string
  machineid() string
}

process {
  init(pid int)
  pid int
  state() string
  executable() string
  command() string
  flags() map[string]string
}

processes {
  []process
}

user {
  init(id string)
  id string
  uid int
  gid int
  sid string
  name string
  home string
  shell string
  enabled bool
  authorizedkeys() authorizedkeys
  sshkeys() []privatekey
}

users {
  []user
}

service {
  init(name string)
  name string
  description() string
  installed() bool
  running() bool
  enabled() bool
  type() string
}

services {
  []service
}

group {
  init(id string)
  id string
  gid int
  sid string
  name string
  members() []user
}

groups {
  []group
}

docker {
  images() []docker.image
  container() []docker.container
}

docker.image {
  id string
  size int
  virtualsize int
  tags []string
  labels map[string]string
}

docker.container {
  id string
  command string
  image string
  imageid string
  names []string
  state string
  status string
  labels map[string]string
}

auditpol {
  []auditpol.entry
}

auditpol.entry {
  machinename      string
	policytarget     string
	subcategory      string
	subcategoryguid  string
	inclusionsetting string
	exclusionsetting string
}

secpol {
  systemaccess() map[string]string
  eventaudit() map[string]string
  registryvalues() map[string]string
  privilegerights() map[string][]string
}

logindefs {
  init(path string)
  file() file
  content(file) string
  params(content) map[string]string
}

mount {
  []mount.point
}

mount.point {
  device string
  path string
  fstype string
  options map[string]string
}

shadow {
  []shadow.entry
}

shadow.entry {
  user string
  password string
  lastchanges string
  mindays string
  maxdays string
  warndays string
  inactivedays string
  expirydates string
  reserved string
}

registrykey {
  init(path string)
  path string
  exists() bool
  properties() map[string]string
  children() []string
}

registrykey.property {
  init(path string, name string)
  path string
  name string
  value() string
  exists() bool
}

yaml.path {
  filepath string
  jsonpath string
  result() string
}

authorizedkeys {
  []authorizedkeys.entry(file, content)
  init(path string)
  path string
  file() file
  content(file) string
}

authorizedkeys.entry {
  line int
  type string
  key string
  label() string
  options() []string
  file file
}

os.rootcertificates {
  []certificate(content)
  files() []file
  content(files) []string
}

parse.certificates {
  []certificate(content, path)
  init(path string)
  path string
  file() file
  content(file) string
}

pkix.name {
  id string
  dn string
  serialnumber string
  commonname string
  country []string
  organization []string
  organizationalunit []string
	locality []string
  province []string
	streetaddress []string
  postalcode []string
	names      map[string]string
	extranames map[string]string
}

pkix.extension {
  identifier string
  critical bool
  value string
}

certificate {
  pem string
  hashs() map[string]string
  serial() string
  subjectkeyid() string
  authoritykeyid() string
  subject() pkix.name
  issuer() pkix.name
  version() int
  notbefore() int
  notafter() int
  signature() string
  signingalgorithm() string
  isca() bool
  keyusage() []string
  extendedkeyusage() []string
  extensions() []pkix.extension
  policyidentifier() []string
  crldistributionpoints() []string
  ocspserver() []string
  issuingcertificateurl() []string
}

privatekey {
  pem string
  path() string
  encrypted() bool
}

vsphere {
  licenses() []vsphere.license
  datacenters() []vsphere.datacenter
}

vsphere.license {
  name string
  total int
  used int
}

esxi {
  host() vsphere.host
  vm() vsphere.vm
}

vsphere.datacenter {
  moid string
  name string
  inventoryPath string
  hosts() []vsphere.host
  vms() []vsphere.vm
  clusters() []vsphere.cluster
}

vsphere.cluster {
  moid string
  name string
  inventoryPath string
  properties dict
  hosts() []vsphere.host
}

vsphere.host {
  moid string
  name string
  inventoryPath string
  properties dict
  standardVswitch() []vsphere.vswitch
  adapters() []vsphere.vmnic
  vmknics() []vsphere.vmknic
  packages() []esxi.vib
  acceptanceLevel() string
  kernelModules() []esxi.kernelmodule
  advancedSettings() map[string]string
  services() []esxi.service
  timezone() esxi.timezone
  ntp() esxi.ntpconfig
  snmp() map[string]string
}

vsphere.vm {
  moid string
  name string
  inventoryPath string
  properties dict
  advancedSettings() map[string]string
}

vsphere.vswitch {
  name string
  properties map[string]string
}

vsphere.vmnic {
  name string
  properties map[string]string
}

vsphere.vmknic {
  name string
  properties map[string]string
}

esxi.vib {
  id string
	name string
	acceptanceLevel string
	creationDate time
	installDate time
	status string
	vendor string
	version string
}

esxi.kernelmodule {
	name string
	modulefile string
	version string
	loaded bool
  enabled bool
  signedStatus string
	signatureDigest string
	signatureFingerprint string
  vibAcceptanceLevel string
}

esxi.service {
  key string
  label string
  required bool
  uninstallable bool
  running bool
  ruleset []string
  policy string
}

esxi.timezone {
  key string
  name string
  description string
  offset int
}

esxi.ntpconfig {
  id string
  server []string
  config []string
}

arista.eos {
  runningConfig() string
  systemConfig() map[string]string
  ipInterfaces() []arista.eos.ipinterface
  interfaces() []arista.eos.interface
  version() dict
  hostname() string
  fqdn() string
}

arista.eos.interface {
  name string
  bandwidth int
  burnedInAddress string
  description string
  forwardingModel string
  hardware string
  interfaceAddress []dict
  interfaceCounters dict
  interfaceMembership string
  interfaceStatistics dict
  interfaceStatus string
  l2Mtu int
  lastStatusChangeTimestamp int
  lineProtocolStatus string
  mtu int
  physicalAddress string
  status() dict
}

arista.eos.ipinterface {
  name string
  address string
  mtu string
}

arista.eos.stp {
  mstInstances() []arista.eos.stp.mst
}

arista.eos.stp.mst {
  instanceId string
  name string
  protocol string
  bridge dict
  rootBridge dict
  regionalRootBridge dict
  interfaces []arista.eos.spt.mstinterface
}

arista.eos.spt.mstinterface {
  id string
  mstInstanceId string
  name string
  priority int
  linkType string
  state string
  cost int
  role string
  inconsistentFeatures dict
  portNumber int
  isEdgePort bool
  detail dict
  boundaryType string
  counters() dict
  features() dict
}

aws.iam {
  users() []aws.iam.user
  roles() []aws.iam.role
  groups() []aws.iam.group
  policies() []aws.iam.policy
  credentialReport() []aws.iam.usercredentialreportentry
  accountPasswordPolicy() map[string]string
  accountSummary() map[string]int
  virtualMfaDevices() []aws.iam.virtualmfadevice
}

aws.iam.usercredentialreportentry {
  init(properties map[string]string)
  properties map[string]string

  arn() string

  accessKey1Active() bool
  accessKey1LastRotated() time
  accessKey1LastUsedDate() time
  accessKey1LastUsedRegion() string
  accessKey1LastUsedService() string

  accessKey2Active() bool
  accessKey2LastRotated() time
  accessKey2LastUsedDate() time
  accessKey2LastUsedRegion() string
  accessKey2LastUsedService() string

  cert1Active() bool
  cert1LastRotated() time

  cert2Active() bool
  cert2LastRotated() time

  mfaActive() bool
  passwordEnabled() bool
  passwordLastChanged() time
  passwordLastUsed() time
  passwordNextRotation() time

  user() aws.iam.user
  userCreationTime() time
}

aws.iam.user {
  arn string
  id string
  name string
  createDate time
  passwordLastUsed time
  tags map[string]string
  policies() []string
  attachedPolicies() []aws.iam.policy
}

aws.iam.policy {
  arn string
  id() string
  name() string
  description() string
  isAttachable() bool
  attachmentCount() int
  createDate() time
  updateDate() time
  scope() string
  versions() []aws.iam.policyversion

  attachedUsers() []aws.iam.user
  attachedRoles() []aws.iam.role
  attachedGroups() []aws.iam.group
}

aws.iam.policyversion {
  arn string
  versionId string
  isDefaultVersion bool
  document() string
  createDate time
}

aws.iam.role {
  arn string
  id string
  name string
  description string
  tags map[string]string
  createDate time
}

aws.iam.group {
  arn string
  id string
  name string
  createDate time
}

aws.iam.virtualmfadevice {
  serialNumber string
  enableDate time
  user aws.iam.user
}

aws.cloudtrail {
  trails() []aws.cloudtrail.trail
}

aws.cloudtrail.trail {
  arn string
  name string
  kmsKeyId string
  isMultiRegionTrail bool
  isOrganizationTrail bool
  logFileValidationEnabled bool
  includeGlobalServiceEvents bool
  s3bucket aws.s3.bucket
  snsTopicARN string
  status() aws.cloudtrail.trailstatus
  cloudWatchLogsLogGroupArn string
  cloudWatchLogsRoleArn string
}

aws.cloudtrail.trailstatus {
  arn string
  isLogging bool
  latestCloudWatchLogsDeliveryError string
  latestCloudWatchLogsDeliveryTime time
  latestDeliveryError string
  latestDeliveryTime time
  latestDigestDeliveryError string
  latestDigestDeliveryTime time
  latestNotificationError string
  latestNotificationTime time
  startLoggingTime time
  stopLoggingTime time
}

aws.s3 {
  buckets() []aws.s3.bucket
}

aws.s3.bucket {
  name string
  policy() aws.s3.bucket.policy
  tags() map[string]string
  acl() []aws.s3.bucket.grant
  owner() map[string]string
  public() bool
  cors() []aws.s3.bucket.corsrule
  location() string
  versioning() map[string]string
  logging() map[string]string
  staticWebsiteHosting() map[string]string
}

aws.s3.bucket.grant {
  id string
  name string
  permission string
  grantee map[string]string
}

aws.s3.bucket.corsrule {
  name string
  allowedHeaders []string
  allowedMethods []string
  allowedOrigins []string
  exposeHeaders []string
  maxAgeSeconds int
}

aws.s3.bucket.policy {
  name string
  document string
  version() string
  id() string
  statements() []aws.s3.bucket.policystatement
}

aws.s3.bucket.policystatement {
  id string
  sid string
  effect string
  principal map[string][]string
  notPrincipal map[string][]string
  action []string
  notAction []string
  grantResource []string
  denyResource []string
  condition string
}

aws.ec2 {
  securityGroups() []aws.ec2.securitygroup
}

aws.ec2.securitygroup {
  id string
  name string
  description string
  tag map[string]string
  vpcid string
  ipPermissions []aws.ec2.securitygroup.ippermission
  ipPermissionsEgress []aws.ec2.securitygroup.ippermission
}

aws.ec2.securitygroup.ippermission {
  id string
  fromPort int
  toPort int
  ipProtocol string
  ipRanges []string
  ipv6Ranges []string
}

gcloud.organization {
  id() string
  name() string
  lifecycleState() string
  iamPolicy() []gcloud.resourcemanager.binding
}

gcloud.project {
  id() string
  name() string
  number() string
  lifecycleState() string
  createTime() time
  labels() map[string]string
  iamPolicy() []gcloud.resourcemanager.binding
}

gcloud.resourcemanager.binding {
  id string
  members []string
  role string
}

gcloud.compute {
  instances() []gcloud.compute.instance
}

gcloud.compute.instance {
  id string
  name string
  cpuPlatform string
  deletionProtection bool
  description string
  hostname string
  labels map[string]string
  status string
  statusMessage string
  tags []string
  metadata map[string]string
  serviceAccounts []gcloud.compute.serviceaccount
}

gcloud.compute.serviceaccount {
  email string
  scopes []string
}

gcloud.storage {
  buckets() []gcloud.storage.bucket
}

gcloud.storage.bucket {
  id string
  name string
  kind string
  labels map[string]string
  location string
  locationType string
  projectNumber string
  storageClass string
  created time
  updated time
  iamPolicy() []gcloud.resourcemanager.binding
  iamConfiguration dict
}

gcloud.sql {
  instances() []gcloud.sql.instance
}

gcloud.sql.instance {
  name string
  backendType string
  connectionName string
  databaseVersion string
  gceZone string
  instanceType string
  kind string
  currentDiskSize int
  maxDiskSize int
  state string
  project string
  region string
  serviceAccountEmailAddress string
  settings dict
}

azuread {
  users() []azuread.user
  groups() []azuread.group
  domains() []azuread.domain
  applications() []azuread.application
  servicePrincipals() []azuread.serviceprincipal
}

azuread.user {
  id string
  displayName string
  givenName string
  surname string
  userPrincipalName string
  accountEnabled bool
  mailNickname string
  mail string
  objectType string
  userType string
  properties dict
}

azuread.group {
  id string
  displayName string
  securityEnabled bool
  mailEnabled bool
  mailNickname string
  mail string
  objectType string
  properties dict
  members() []azuread.user
}

azuread.domain {
  name string
  isVerified bool
  isDefault bool
  authenticationType string
  properties dict
}

azuread.application {
  id string
}

azuread.serviceprincipal {
  id string
}

azurerm {
  resources() []azurerm.resource
}

azurerm.resource {
  id string
  name string
  kind string
  location string
  tags map[string]string
  type string

  managedBy string
  sku dict
  plan dict
  identity dict

  provisioningState string
  createdTime time
  changedTime time
}

azurerm.compute {
  vms() []azurerm.compute.vm
  disks() []azurerm.compute.disk
}

azurerm.compute.vm {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  extensions() []dict
  osDisk() azurerm.compute.disk
  dataDisks() []azurerm.compute.disk
}

azurerm.compute.disk {
  id string
  name string
  location string
  tags map[string]string
  type string
  managedBy string
  managedByExtended []string
  zones []string
  sku dict
  properties dict
}

azurerm.network {
  interfaces() []azurerm.network.interface
  securityGroups() []azurerm.network.securitygroup
  watchers() []azurerm.network.watcher
}

azurerm.network.interface {
  id string
  name string
  location string
  tags map[string]string
  type string
  etag string
  properties dict
  vm() azurerm.compute.vm
}

azurerm.network.securitygroup {
  id string
  name string
  location string
  tags map[string]string
  type string
  etag string
  properties dict
  interfaces []azure.network.interface
	securityRules []azurerm.network.securityrule
  defaultSecurityRules []azurerm.network.securityrule
}

azurerm.network.securityrule {
  id string
  name string
  etag string
  properties dict
  destinationPortRange []dict
}

azurerm.network.watcher {
  id string
  name string
  location string
  tags map[string]string
  type string
  etag string
  properties dict
}

azurerm.storage {
  accounts() []azurerm.storage.account
}

azurerm.storage.account {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  identity dict
  sku dict
  kind string
  containers() []azurerm.storage.container
}

azurerm.storage.container {
  id string
  name string
  type string
  etag string
  properties dict
}

azurerm.web {
  apps() []azurerm.web.appsite
  availableRuntimes() []dict
}

azurerm.web.appsite {
  id string
  name string
  kind string
  location string
  type string
  tags map[string]string
  properties dict
  identity dict

  configuration() azurerm.web.appsiteconfig
  authenticationSettings() azurerm.web.appsiteauthsettings
  metadata() dict
  applicationSettings() dict
  connectionSettings() dict
  stack() dict
}

azurerm.web.appsiteauthsettings {
  id string
  name string
  kind string
  type string
  properties dict
}

azurerm.web.appsiteconfig {
  id string
  name string
  kind string
  type string
  properties dict
}

azurerm.sql {
  servers() []azurerm.sql.server
}

azurerm.sql.server {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  databases() []azurerm.sql.database
  firewallRules() []azurerm.sql.firewallrule
  azureAdAdministrators() []azurerm.sql.server.administrator
  connectionPolicy() dict
  auditingPolicy() dict
  securityAlertPolicy() dict
  encryptionProtector() dict
}

azurerm.sql.server.administrator {
  id string
  name string
  type string
  administratorType string
  login string
  sid string
  tenantId string
}

azurerm.sql.database {
  id string
  name string
  type string
  collation string
  creationDate time
  containmentState int
  currentServiceObjectiveId string
  databaseId string
  earliestRestoreDate time
  createMode string
  sourceDatabaseId string
  sourceDatabaseDeletionDate time
  restorePointInTime time
  recoveryServicesRecoveryPointResourceId string
  edition string
  maxSizeBytes string
  requestedServiceObjectiveId string
  requestedServiceObjectiveName string
  serviceLevelObjective string
  status string
  elasticPoolName string
  defaultSecondaryLocation string
  serviceTierAdvisors dict
  recommendedIndex dict
  failoverGroupId string
  readScale string
  sampleName string
  zoneRedundant bool

  transparentDataEncryption() dict
  advisor() []dict
  threadDetectionPolicy() dict
  connectionPolicy() dict
  auditingPolicy() dict
  usage() []azurerm.sql.databaseusage
}

azurerm.sql.databaseusage {
  id string
  name string
  resourceName string
  displayName string
  currentValue int
  limit int
  unit string
  nextResetTime time
}

azurerm.postgresql {
   servers() []azurerm.postgresql.server
}

azurerm.postgresql.server {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  configuration() []azurerm.sql.configuration
  databases() []azurerm.postgresql.database
  firewallRules() []azurerm.sql.firewallrule
}

azurerm.postgresql.database {
  id string
  name string
  type string
  charset string
  collation string
}

azurerm.mysql {
  servers() []azurerm.mysql.server
}

azurerm.mysql.server {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  configuration() []azurerm.sql.configuration
  databases() []azurerm.mysql.database
  firewallRules() []azurerm.sql.firewallrule
}

azurerm.mysql.database {
  id string
  name string
  type string
  charset string
  collation string
}

azurerm.mariadb {
  servers() []azurerm.mariadb.server
}

azurerm.mariadb.server {
  id string
  name string
  location string
  tags map[string]string
  type string
  properties dict
  configuration() []azurerm.sql.configuration
  databases() []azurerm.mariadb.database
  firewallRules() []azurerm.sql.firewallrule
}

azurerm.mariadb.database {
  id string
  name string
  type string
  charset string
  collation string
}

azurerm.sql.configuration {
  id string
  name string
  type string
  value string
  description string
  defaultValue string
  dataType string
  allowedValues string
  source string
}

azurerm.sql.firewallrule {
  id string
  name string
  type string
  startIpAddress string
  endIpAddress string
}

azurerm.keyvault {
  vaults() []azurerm.keyvault.vault
}

azurerm.keyvault.vault {
  id string
  vaultName string
  type string
  location string
  tags map[string]string

  vaultUri() string
  properties() dict

  keys() []azurerm.keyvault.key
  certificates() []azurerm.keyvault.certificate
  secrets() []azurerm.keyvault.secret
  diagnosticSettings() []azurerm.monitor.diagnosticsetting
}

azurerm.keyvault.key {
  kid string
  tags map[string]string
  managed bool

  enabled bool
  notBefore time
  expires time
  created time
  updated time
  recoveryLevel string

  keyName() string
  version() string
  versions() []azurerm.keyvault.key
}

azurerm.keyvault.certificate {
  id string
  tags map[string]string
  x5t string

  enabled bool
  notBefore time
  expires time
  created time
  updated time
  recoveryLevel string

  certName() string
  version() string
  versions() []azurerm.keyvault.certificate
}

azurerm.keyvault.secret {
  id string
  tags map[string]string
  contentType string
  managed bool

  enabled bool
  notBefore time
  expires time
  created time
  updated time

  secretName() string
  version() string
  versions() []azurerm.keyvault.secret
}

azurerm.monitor {
  logProfiles() []azurerm.monitor.logprofile
}

azurerm.monitor.logprofile {
  id string
  name string
  location string
  type string
  tags map[string]string
  properties dict
  storageAccount azurerm.storage.account
}

azurerm.monitor.diagnosticsetting {
  id string
  name string
  type string
  properties dict
  storageAccount azurerm.storage.account
}
